% !TEX root = ../main.tex

\subsection[04b MT]{Esercizio 04b Marco Turchetto}

\lstinputlisting[ basicstyle=\small\ttfamily, tabsize=3,%
			keywordstyle=\color{green}\bfseries, commentstyle=\color{gray}, stringstyle=\color{black},%
			numbers=left, numberstyle=\tiny, frame=lines]
			{./esercizi/2015_02_02-04b-MT-code.txt}
			
La complessità dell'algoritmo è eguale ad una esplorazione in profondità dell'albero.
$\BigTheta{n}$ nel caso peggiore, $\BigO{\log n}$ nel caso medio.

La correttezza dell'algoritmo si dimostra analizzando i quattro casi dell'algoritmo.

Dando per ipotesi l'esistenza delle chiavi $k_1$ e $k_2$ uniche:

\begin{enumerate}
\item se il mio albero ha come radice un elemento eguale a $k_2$, allora $k_1$ deve per forza essere in uno dei due sotto-alberi della radice e perciò $k_1$ non è antenato di $k_2$;
	
\item se il mio albero ha come radice un elemento eguale a $k_1$, allora $k_2$ deve per forza essere in uno dei due sotto-alberi della radice e perciò $k_1$ è antenato di $k_2$;
	 
\item se entrambe le chiavi $k_1$ e $k_2$ sono minori del valore dell'elemento della radice, allora cerco se $k_1$ è antenato di $k_2$ nel sotto-albero sinistro;
	
\item se entrambe le chiavi $k_1$ e $k_2$ sono maggiori del valore dell'elemento della radice, allora cerco se $k_1$ è antenato di $k_2$ nel sotto-albero destro.
	
\item se nessuno dei casi precedenti si verifica, le chiavi sono in sotto-alberi diversi e perciò $k_1$ non è antenato di $k_2$.
\end{enumerate}
